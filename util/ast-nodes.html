<div class='ast-node'>
    <h3>Node(type, start, end, children())</h3>
    <dl>
        <dt>type</dt>
        <dd><em>(string)</em> The node type</dd>
        <dt>start</dt>
        <dd><em>(number)</em> The starting position of the node within the input string</dd>
        <dt>end</dt>
        <dd><em>(number)</em> The ending position of the node within the input string</dd>
        <dt>children()</dt>
        <dd><em>(array)</em> Returns an array of child nodes</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ArrayComprehension(qualifiers, expression, start, end)</h3>
    <dl>
        <dt>qualifiers</dt>
        <dd><em>(Node)</em> </dd>
        <dt>expression</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ArrayLiteral(elements, start, end)</h3>
    <dl>
        <dt>elements</dt>
        <dd><em>[Node | null]</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ArrayPattern(elements, start, end)</h3>
    <dl>
        <dt>elements</dt>
        <dd><em>[PatternElement | PatternRestElement]</em> A list of of destructuring pattern elements</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ArrowFunction(kind, params, body, start, end)</h3>
    <dl>
        <dt>kind</dt>
        <dd><em>(Node)</em> </dd>
        <dt>params</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ArrowFunctionHead(parameters, start, end)</h3>
    <dl>
        <dt>parameters</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>AssignmentExpression(operator, left, right, start, end)</h3>
    <dl>
        <dt>operator</dt>
        <dd><em>(string)</em> An assignment operator</dd>
        <dt>left</dt>
        <dd><em>(Node)</em> The left-hand-side of the assignment operator</dd>
        <dt>right</dt>
        <dd><em>(Node)</em> The right-hand-side of the assignment operator</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>BinaryExpression(operator, left, right, start, end)</h3>
    <dl>
        <dt>operator</dt>
        <dd><em>(string)</em> A binary operator</dd>
        <dt>left</dt>
        <dd><em>(Node)</em> The left operand expression</dd>
        <dt>right</dt>
        <dd><em>(Node)</em> The right operand expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Block(statements, start, end)</h3>
    <dl>
        <dt>statements</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Boolean(value, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(boolean)</em> The value of the boolean literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>BreakStatement(label, start, end)</h3>
    <dl>
        <dt>label</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>CallExpression(callee, arguments, start, end)</h3>
    <dl>
        <dt>callee</dt>
        <dd><em>(Node)</em> An expression</dd>
        <dt>arguments</dt>
        <dd><em>[Node]</em> A list of call arguments</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>CatchClause(param, body, start, end)</h3>
    <dl>
        <dt>param</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ClassBody(elements, start, end)</h3>
    <dl>
        <dt>elements</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ClassDeclaration(identifier, base, body, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>base</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ClassElement(static, method, start, end)</h3>
    <dl>
        <dt>static</dt>
        <dd><em>(Node)</em> </dd>
        <dt>method</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ClassExpression(identifier, base, body, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>base</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ComprehensionFor(left, right, start, end)</h3>
    <dl>
        <dt>left</dt>
        <dd><em>(Node)</em> </dd>
        <dt>right</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ComprehensionIf(test, start, end)</h3>
    <dl>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ComputedPropertyName(expression, start, end)</h3>
    <dl>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ConditionalExpression(test, consequent, alternate, start, end)</h3>
    <dl>
        <dt>test</dt>
        <dd><em>(Node)</em> A test expression</dd>
        <dt>consequent</dt>
        <dd><em>(Node)</em> The expression evaluated if the test passes</dd>
        <dt>alternate</dt>
        <dd><em>(Node)</em> The expression evaluated if the test fails</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ContinueStatement(label, start, end)</h3>
    <dl>
        <dt>label</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>DebuggerStatement(start, end)</h3>
    <dl>
    </dl>
</div>
<div class='ast-node'>
    <h3>DoWhileStatement(body, test, start, end)</h3>
    <dl>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>EmptyStatement(start, end)</h3>
    <dl>
    </dl>
</div>
<div class='ast-node'>
    <h3>ExportDeclaration(declaration, start, end)</h3>
    <dl>
        <dt>declaration</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ExportSpecifier(local, exported, start, end)</h3>
    <dl>
        <dt>local</dt>
        <dd><em>(Node)</em> </dd>
        <dt>exported</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ExportsList(specifiers, from, start, end)</h3>
    <dl>
        <dt>specifiers</dt>
        <dd><em>(Node)</em> </dd>
        <dt>from</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ExpressionStatement(expression, start, end)</h3>
    <dl>
        <dt>expression</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ForInStatement(left, right, body, start, end)</h3>
    <dl>
        <dt>left</dt>
        <dd><em>(Node)</em> </dd>
        <dt>right</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ForOfStatement(left, right, body, start, end)</h3>
    <dl>
        <dt>left</dt>
        <dd><em>(Node)</em> </dd>
        <dt>right</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ForStatement(initializer, test, update, body, start, end)</h3>
    <dl>
        <dt>initializer</dt>
        <dd><em>(Node)</em> </dd>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
        <dt>update</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>FormalParameter(pattern, initializer, start, end)</h3>
    <dl>
        <dt>pattern</dt>
        <dd><em>(Node)</em> </dd>
        <dt>initializer</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>FunctionBody(statements, start, end)</h3>
    <dl>
        <dt>statements</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>FunctionDeclaration(kind, identifier, params, body, start, end)</h3>
    <dl>
        <dt>kind</dt>
        <dd><em>(Node)</em> </dd>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>params</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>FunctionExpression(kind, identifier, params, body, start, end)</h3>
    <dl>
        <dt>kind</dt>
        <dd><em>(Node)</em> </dd>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>params</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>GeneratorComprehension(qualifiers, expression, start, end)</h3>
    <dl>
        <dt>qualifiers</dt>
        <dd><em>(Node)</em> </dd>
        <dt>expression</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Identifier(value, context, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(string)</em> The string value of the identifier</dd>
        <dt>context</dt>
        <dd><em>(string)</em> The context in which the identifier appears (&quot;&quot;, &quot;variable&quot;, &quot;declaration&quot;)</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>IfStatement(test, consequent, alternate, start, end)</h3>
    <dl>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
        <dt>consequent</dt>
        <dd><em>(Node)</em> </dd>
        <dt>alternate</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ImportDeclaration(specifiers, from, start, end)</h3>
    <dl>
        <dt>specifiers</dt>
        <dd><em>(Node)</em> </dd>
        <dt>from</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ImportDefaultDeclaration(identifier, from, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>from</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ImportSpecifier(imported, local, start, end)</h3>
    <dl>
        <dt>imported</dt>
        <dd><em>(Node)</em> </dd>
        <dt>local</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>LabelledStatement(label, statement, start, end)</h3>
    <dl>
        <dt>label</dt>
        <dd><em>(Node)</em> </dd>
        <dt>statement</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>MemberExpression(object, property, computed, start, end)</h3>
    <dl>
        <dt>object</dt>
        <dd><em>(Node)</em> An expression evaulating to an object</dd>
        <dt>property</dt>
        <dd><em>(Node)</em> An expression evaluating to a property name</dd>
        <dt>computed</dt>
        <dd><em>(boolean)</em> True if the property name is computed</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>MethodDefinition(kind, name, params, body, start, end)</h3>
    <dl>
        <dt>kind</dt>
        <dd><em>(string)</em> The type of method</dd>
        <dt>name</dt>
        <dd><em>(Node)</em> The method name</dd>
        <dt>params</dt>
        <dd><em>[FormalParameter]</em> A list of formal parameters</dd>
        <dt>body</dt>
        <dd><em>(FunctionBody)</em> The function body</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Module(statements, start, end)</h3>
    <dl>
        <dt>statements</dt>
        <dd><em>[Node]</em> A list of statements</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ModuleAlias(identifier, path, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>path</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ModuleBody(statements, start, end)</h3>
    <dl>
        <dt>statements</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ModuleDeclaration(identifier, body, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ModuleImport(identifier, from, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
        <dt>from</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ModulePath(elements, start, end)</h3>
    <dl>
        <dt>elements</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>NewExpression(callee, arguments, start, end)</h3>
    <dl>
        <dt>callee</dt>
        <dd><em>(Node)</em> An expression</dd>
        <dt>arguments</dt>
        <dd><em>[Node]</em> A list of call arguments</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Null(start, end)</h3>
    <dl>
    </dl>
</div>
<div class='ast-node'>
    <h3>Number(value, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(number)</em> The mathmatical value of the number literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ObjectLiteral(properties, start, end)</h3>
    <dl>
        <dt>properties</dt>
        <dd><em>[PropertyDefinition | MethodDefinition]</em> A list of properties and methods defined in the object literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ObjectPattern(properties, start, end)</h3>
    <dl>
        <dt>properties</dt>
        <dd><em>[PatternProperty]</em> A list of destructuring pattern properties</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ParenExpression(expression, start, end)</h3>
    <dl>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression contained within parenthesis</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>PatternElement(pattern, initializer, start, end)</h3>
    <dl>
        <dt>pattern</dt>
        <dd><em>(Node)</em> A destructuring target pattern</dd>
        <dt>initializer</dt>
        <dd><em>(Node?)</em> A default initializer expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>PatternProperty(name, pattern, initializer, start, end)</h3>
    <dl>
        <dt>name</dt>
        <dd><em>(Node)</em> The destructuring property name</dd>
        <dt>pattern</dt>
        <dd><em>(Node?)</em> A destructuring target pattern</dd>
        <dt>initializer</dt>
        <dd><em>(Node?)</em> A default initializer expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>PatternRestElement(pattern, start, end)</h3>
    <dl>
        <dt>pattern</dt>
        <dd><em>(Node)</em> A destructuring target</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>PropertyDefinition(name, expression, start, end)</h3>
    <dl>
        <dt>name</dt>
        <dd><em>(String | Number | Identifier | ComputedPropertyName)</em> The property name</dd>
        <dt>expression</dt>
        <dd><em>(Node?)</em> An expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>RegularExpression(value, flags, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(string)</em> The raw value of the regular expression literal</dd>
        <dt>flags</dt>
        <dd><em>(string)</em> The set of flags for the regular expression literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>RestParameter(identifier, start, end)</h3>
    <dl>
        <dt>identifier</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ReturnStatement(argument, start, end)</h3>
    <dl>
        <dt>argument</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>Script(statements, start, end)</h3>
    <dl>
        <dt>statements</dt>
        <dd><em>[Node]</em> A list of statements</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>SequenceExpression(expressions, start, end)</h3>
    <dl>
        <dt>expressions</dt>
        <dd><em>[Node]</em> A list of expressions</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>SpreadExpression(expression, start, end)</h3>
    <dl>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>String(value, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(string)</em> The value of the string literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>SuperExpression(start, end)</h3>
    <dl>
    </dl>
</div>
<div class='ast-node'>
    <h3>SwitchCase(test, consequent, start, end)</h3>
    <dl>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
        <dt>consequent</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>SwitchStatement(descriminant, cases, start, end)</h3>
    <dl>
        <dt>descriminant</dt>
        <dd><em>(Node)</em> </dd>
        <dt>cases</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>TaggedTemplateExpression(tag, template, start, end)</h3>
    <dl>
        <dt>tag</dt>
        <dd><em>(Node)</em> The template tag</dd>
        <dt>template</dt>
        <dd><em>(TemplateExpression)</em> A template</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>TemplateExpression(literals, substitutions, start, end)</h3>
    <dl>
        <dt>literals</dt>
        <dd><em>(Node)</em> </dd>
        <dt>substitutions</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>TemplatePart(value, templateEnd, start, end)</h3>
    <dl>
        <dt>value</dt>
        <dd><em>(string)</em> The string value of the template fragment</dd>
        <dt>templateEnd</dt>
        <dd><em>(boolean)</em> True if this template fragment terminates the template literal</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>ThisExpression(start, end)</h3>
    <dl>
    </dl>
</div>
<div class='ast-node'>
    <h3>ThrowStatement(expression, start, end)</h3>
    <dl>
        <dt>expression</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>TryStatement(block, handler, finalizer, start, end)</h3>
    <dl>
        <dt>block</dt>
        <dd><em>(Node)</em> </dd>
        <dt>handler</dt>
        <dd><em>(Node)</em> </dd>
        <dt>finalizer</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>UnaryExpression(operator, expression, start, end)</h3>
    <dl>
        <dt>operator</dt>
        <dd><em>(string)</em> A unary operator</dd>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>UpdateExpression(operator, expression, prefix, start, end)</h3>
    <dl>
        <dt>operator</dt>
        <dd><em>(string)</em> An update operator</dd>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression</dd>
        <dt>prefix</dt>
        <dd><em>(boolean)</em> True if the operator is a prefix</dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>VariableDeclaration(kind, declarations, start, end)</h3>
    <dl>
        <dt>kind</dt>
        <dd><em>(Node)</em> </dd>
        <dt>declarations</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>VariableDeclarator(pattern, initializer, start, end)</h3>
    <dl>
        <dt>pattern</dt>
        <dd><em>(Node)</em> </dd>
        <dt>initializer</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>WhileStatement(test, body, start, end)</h3>
    <dl>
        <dt>test</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>WithStatement(object, body, start, end)</h3>
    <dl>
        <dt>object</dt>
        <dd><em>(Node)</em> </dd>
        <dt>body</dt>
        <dd><em>(Node)</em> </dd>
    </dl>
</div>
<div class='ast-node'>
    <h3>YieldExpression(delegate, expression, start, end)</h3>
    <dl>
        <dt>delegate</dt>
        <dd><em>(boolean)</em> True if the yield expression is delegating</dd>
        <dt>expression</dt>
        <dd><em>(Node)</em> An expression</dd>
    </dl>
</div>